{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/hashing/sha256.ts", "../../thirdweb/src/utils/client-id.ts", "../../thirdweb/src/client/client.ts", "../../thirdweb/src/rpc/actions/eth_getBlockByHash.ts", "../../thirdweb/src/rpc/actions/eth_getTransactionByHash.ts", "../../thirdweb/src/wallets/in-app/core/users/getUser.ts", "../../thirdweb/src/transaction/resolve-method.ts", "../../thirdweb/src/utils/signatures/sign.ts", "../../thirdweb/src/transaction/serialize-transaction.ts", "../../thirdweb/src/transaction/actions/sign-transaction.ts", "../../thirdweb/src/utils/encoding/helpers/trim.ts", "../../thirdweb/src/utils/encoding/from-bytes.ts", "../../thirdweb/src/auth/constants.ts", "../../thirdweb/src/auth/is-erc6492-signature.ts", "../../thirdweb/src/auth/serialize-erc6492-signature.ts", "../../thirdweb/src/auth/verify-hash.ts", "../../thirdweb/src/auth/verify-typed-data.ts"],
  "sourcesContent": ["import { sha256 as noble_sha256 } from \"@noble/hashes/sha256\";\r\nimport {\r\n  type Hex,\r\n  hexToUint8Array,\r\n  isHex,\r\n  uint8ArrayToHex,\r\n} from \"../encoding/hex.js\";\r\n\r\ntype To = \"hex\" | \"bytes\";\r\n\r\ntype Sha256Hash<TTo extends To> =\r\n  | (TTo extends \"bytes\" ? Uint8Array : never)\r\n  | (TTo extends \"hex\" ? Hex : never);\r\n\r\n/**\r\n * Calculates the SHA256 hash of the given value.\r\n * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.\r\n * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.\r\n * @returns The SHA256 hash of the value in the specified format.\r\n * @example\r\n * ```ts\r\n * import { sha256 } from \"thirdweb/utils\";\r\n * const hash = sha256(\"0x1234\");\r\n * ```\r\n * @utils\r\n */\r\nexport function sha256<TTo extends To = \"hex\">(\r\n  value: Hex | Uint8Array,\r\n  to?: TTo,\r\n): Sha256Hash<TTo> {\r\n  const bytes = noble_sha256(\r\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\r\n  );\r\n  if (to === \"bytes\") {\r\n    return bytes as Sha256Hash<TTo>;\r\n  }\r\n  return uint8ArrayToHex(bytes) as Sha256Hash<TTo>;\r\n}\r\n", "import { LruMap } from \"./caching/lru.js\";\r\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\r\nimport { sha256 } from \"./hashing/sha256.js\";\r\n\r\nconst cache = new LruMap<string>(4096);\r\n\r\n/**\r\n * @param secretKey - the secret key to compute the client id from\r\n * @returns the 32 char hex client id\r\n * @internal\r\n */\r\nexport function computeClientIdFromSecretKey(secretKey: string): string {\r\n  if (cache.has(secretKey)) {\r\n    return cache.get(secretKey) as string;\r\n  }\r\n  // we slice off the leading `0x` and then take the first 32 chars\r\n  const cId = sha256(stringToBytes(secretKey)).slice(2, 34);\r\n  cache.set(secretKey, cId);\r\n  return cId;\r\n}\r\n", "import { computeClientIdFromSecretKey } from \"../utils/client-id.js\";\r\nimport { isJWT } from \"../utils/jwt/is-jwt.js\";\r\nimport type { Prettify } from \"../utils/type-utils.js\";\r\n\r\ntype FetchConfig = {\r\n  requestTimeoutMs?: number;\r\n  keepalive?: boolean;\r\n  headers?: HeadersInit;\r\n};\r\n\r\ntype ClientOptions = Prettify<{\r\n  /**\r\n   * The configuration options for the client.\r\n   */\r\n  config?: {\r\n    /**\r\n     * The configuration options for the RPC client.\r\n     */\r\n    rpc?: {\r\n      /**\r\n       * The configuration options for the fetch function.\r\n       * @default {}\r\n       */\r\n      fetch?: FetchConfig;\r\n      /**\r\n       * The maximum number of requests to batch together.\r\n       * @default 100\r\n       */\r\n      maxBatchSize?: number;\r\n      /**\r\n       * The maximum time to wait before sending a batch of requests.\r\n       * @default 0 (no timeout)\r\n       */\r\n      batchTimeoutMs?: number;\r\n    };\r\n    /**\r\n     * The configuration options for the storage client.\r\n     */\r\n    storage?: {\r\n      /**\r\n       * The configuration options for the fetch function.\r\n       * @default {}\r\n       */\r\n      fetch?: FetchConfig;\r\n      /**\r\n       * The IPFS gateway URL.\r\n       * @default \"https://<your_client_id>.ipfscdn.io/ipfs/<cid>\"\r\n       */\r\n      gatewayUrl?: string;\r\n    };\r\n  };\r\n}>;\r\n\r\nexport type CreateThirdwebClientOptions = Prettify<\r\n  (\r\n    | {\r\n        clientId: string;\r\n        secretKey?: string;\r\n      }\r\n    | {\r\n        clientId?: string;\r\n        secretKey: string;\r\n      }\r\n  ) &\r\n    ClientOptions\r\n>;\r\n\r\nexport type ThirdwebClient = {\r\n  readonly clientId: string;\r\n  readonly secretKey: string | undefined;\r\n} & Readonly<ClientOptions>;\r\n\r\n/**\r\n * Creates a Thirdweb client using the provided client ID (client-side) or secret key (server-side).\r\n *\r\n * Get your client ID and secret key from the Thirdweb dashboard [here](https://thirdweb.com/dashboard/settings/api-keys).\r\n * **Never share your secret key with anyone.\r\n *\r\n * A client is necessary for most functions in the thirdweb SDK. It provides access to thirdweb APIs including built-in RPC, storage, and more.\r\n *\r\n * @param options - The options for creating the client.\r\n * @param [options.clientId] - The client ID to use for thirdweb services.\r\n * @param [options.secretKey] - The secret key to use for thirdweb services.\r\n * @returns The created Thirdweb client.\r\n * @throws An error if neither `clientId` nor `secretKey` is provided.\r\n *\r\n * @example\r\n * Create a client on the client side (client ID):\r\n * ```ts\r\n * import { createThirdwebClient } from \"thirdweb\";\r\n *\r\n * const client = createThirdwebClient({ clientId: \"...\" });\r\n * ```\r\n *\r\n * Create a client on the server (secret key):\r\n * ```ts\r\n * import { createThirdwebClient } from \"thirdweb\";\r\n *\r\n * const client = createThirdwebClient({ secretKey: \"...\" });\r\n * ```\r\n */\r\nexport function createThirdwebClient(\r\n  options: CreateThirdwebClientOptions,\r\n): ThirdwebClient {\r\n  const { clientId, secretKey, ...rest } = options;\r\n\r\n  let realClientId: string | undefined = clientId;\r\n\r\n  if (secretKey) {\r\n    if (isJWT(secretKey)) {\r\n      // when passing a JWT as secret key we HAVE to also have a clientId\r\n      if (!clientId) {\r\n        throw new Error(\"clientId must be provided when using a JWT secretKey\");\r\n      }\r\n    } else {\r\n      realClientId = computeClientIdFromSecretKey(secretKey);\r\n    }\r\n  }\r\n\r\n  // only path we get here is if we have no secretKey and no clientId\r\n  if (!realClientId) {\r\n    throw new Error(\"clientId or secretKey must be provided\");\r\n  }\r\n\r\n  return {\r\n    ...rest,\r\n    clientId: realClientId,\r\n    secretKey,\r\n  } as const;\r\n}\r\n", "import {\r\n  type EIP1193RequestFn,\r\n  type EIP1474Methods,\r\n  type GetBlockReturnType,\r\n  type Hash,\r\n  formatBlock,\r\n} from \"viem\";\r\n\r\ntype GetBlockByHashParams<TIncludeTransactions extends boolean = false> = {\r\n  /** Whether or not to include transaction data in the response. */\r\n  includeTransactions?: TIncludeTransactions;\r\n} & {\r\n  /** Hash of the block. */\r\n  blockHash: Hash;\r\n};\r\n\r\n/**\r\n * Retrieves a block by its hash.\r\n * @param request - The EIP1193 request function.\r\n * @param params - The parameters for the block retrieval.\r\n * @returns A promise that resolves to the retrieved block.\r\n * @throws An error if the block is not found.\r\n * @rpc\r\n * @example\r\n * ```ts\r\n * import { getRpcClient, eth_getBlockByHash } from \"thirdweb/rpc\";\r\n * const rpcRequest = getRpcClient({ client, chain });\r\n * const block = await eth_getBlockByHash(rpcRequest, {\r\n * blockHash: \"0x...\",\r\n * includeTransactions: true,\r\n * });\r\n * ```\r\n */\r\nexport async function eth_getBlockByHash<\r\n  TIncludeTransactions extends boolean = false,\r\n>(\r\n  request: EIP1193RequestFn<EIP1474Methods>,\r\n  params: GetBlockByHashParams<TIncludeTransactions>,\r\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions>> {\r\n  const includeTransactions = params.includeTransactions ?? false;\r\n\r\n  const block = await request({\r\n    method: \"eth_getBlockByHash\",\r\n    params: [params.blockHash, includeTransactions],\r\n  });\r\n  if (!block) {\r\n    throw new Error(\"Block not found\");\r\n  }\r\n  return formatBlock(block) as GetBlockReturnType<\r\n    undefined,\r\n    TIncludeTransactions\r\n  >;\r\n}\r\n", "import {\r\n  type EIP1193RequestFn,\r\n  type EIP1474Methods,\r\n  type Hash,\r\n  type Transaction,\r\n  formatTransaction,\r\n} from \"viem\";\r\n\r\ntype GetTransactionByHashParameters = {\r\n  hash: Hash;\r\n};\r\n\r\n/**\r\n * Retrieves a transaction by its hash.\r\n * @param request - The EIP1193 request function.\r\n * @param params - The parameters for retrieving the transaction.\r\n * @returns A promise that resolves to the transaction.\r\n * @throws An error if the transaction is not found.\r\n * @rpc\r\n * @example\r\n * ```ts\r\n * import { getRpcClient, eth_getTransactionByHash } from \"thirdweb/rpc\";\r\n * const rpcRequest = getRpcClient({ client, chain });\r\n *  const transaction = await eth_getTransactionByHash(rpcRequest, {\r\n *  hash: \"0x...\",\r\n * });\r\n * ```\r\n */\r\nexport async function eth_getTransactionByHash(\r\n  request: EIP1193RequestFn<EIP1474Methods>,\r\n  params: GetTransactionByHashParameters,\r\n): Promise<Transaction> {\r\n  const receipt = await request({\r\n    method: \"eth_getTransactionByHash\",\r\n    params: [params.hash],\r\n  });\r\n\r\n  if (!receipt) {\r\n    throw new Error(\"Transaction not found.\");\r\n  }\r\n\r\n  return formatTransaction(receipt);\r\n}\r\n", "import type { ThirdwebClient } from \"../../../../client/client.js\";\r\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\r\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\r\nimport type { OneOf, Prettify } from \"../../../../utils/type-utils.js\";\r\nimport type { Profile } from \"../authentication/types.js\";\r\nimport type { Ecosystem } from \"../wallet/types.js\";\r\n\r\nexport type GetUserResult = {\r\n  userId: string;\r\n  walletAddress: string;\r\n  email?: string;\r\n  phone?: string;\r\n  createdAt: string;\r\n  profiles: Profile[];\r\n};\r\n\r\n/**\r\n * Gets user based on the provided query parameters.\r\n * @note This function is only available on the server (a secret key is required in the client).\r\n *\r\n * @param options - The options for the get user function.\r\n * @param options.client - The Thirdweb client with a secret key included.\r\n * @param [options.walletAddress] - The wallet address generated by thirdweb to query by.\r\n * @param [options.email] - The email to query by.\r\n * @param [options.phone] - The phone number to query by.\r\n * @param [options.id] - The user ID to query by.\r\n * @param [options.externalWalletAddress] - The linked external wallet address to query by.\r\n *\r\n * @returns A user object or null if not found.\r\n *\r\n * @example\r\n * import { getUser } from \"thirdweb/wallets\";\r\n *\r\n * const user = await getUser({\r\n *   client,\r\n *   walletAddress: \"0x123...\",\r\n * });\r\n *\r\n * @wallet\r\n */\r\nexport async function getUser({\r\n  client,\r\n  walletAddress,\r\n  email,\r\n  phone,\r\n  id,\r\n  externalWalletAddress,\r\n  ecosystem,\r\n}: Prettify<\r\n  {\r\n    client: ThirdwebClient;\r\n    ecosystem?: Ecosystem;\r\n  } & OneOf<{\r\n    walletAddress?: string;\r\n    email?: string;\r\n    phone?: string;\r\n    id?: string;\r\n    externalWalletAddress?: string;\r\n  }>\r\n>): Promise<GetUserResult | null> {\r\n  if (!client.secretKey) {\r\n    throw new Error(\r\n      \"A secret key is required to query for users. If you're making this request from the server, please add a secret key to your client.\",\r\n    );\r\n  }\r\n\r\n  const url = new URL(\r\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2023-11-30/embedded-wallet/user-details`,\r\n  );\r\n\r\n  if (walletAddress) {\r\n    url.searchParams.set(\"queryBy\", \"walletAddress\");\r\n    url.searchParams.set(\"walletAddress\", walletAddress);\r\n  } else if (email) {\r\n    url.searchParams.set(\"queryBy\", \"email\");\r\n    url.searchParams.set(\"email\", email);\r\n  } else if (phone) {\r\n    url.searchParams.set(\"queryBy\", \"phone\");\r\n    url.searchParams.set(\"phone\", phone);\r\n  } else if (id) {\r\n    url.searchParams.set(\"queryBy\", \"id\");\r\n    url.searchParams.set(\"id\", id);\r\n  } else if (externalWalletAddress) {\r\n    url.searchParams.set(\"queryBy\", \"externalWalletAddress\");\r\n    url.searchParams.set(\"externalWalletAddress\", externalWalletAddress);\r\n  } else {\r\n    throw new Error(\r\n      \"Please provide a walletAddress, email, phone, id, or externalWalletAddress to query for users.\",\r\n    );\r\n  }\r\n\r\n  const clientFetch = getClientFetch(client, ecosystem);\r\n\r\n  const res = await clientFetch(url.toString());\r\n\r\n  if (!res.ok) {\r\n    throw new Error(\"Failed to get profiles\");\r\n  }\r\n\r\n  const data = (await res.json()) as {\r\n    userId: string;\r\n    walletAddress: string;\r\n    email?: string;\r\n    phone?: string;\r\n    createdAt: string;\r\n    linkedAccounts: Profile[];\r\n  }[];\r\n\r\n  return (\r\n    data.map((item) => ({\r\n      userId: item.userId,\r\n      walletAddress: item.walletAddress,\r\n      email: item.email,\r\n      phone: item.phone,\r\n      createdAt: item.createdAt,\r\n      profiles: item.linkedAccounts,\r\n    }))[0] || null\r\n  );\r\n}\r\n", "import type { Abi, AbiFunction } from \"abitype\";\r\nimport { parseAbiItem } from \"abitype\";\r\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\r\nimport type { ThirdwebContract } from \"../contract/contract.js\";\r\n\r\n/**\r\n * Resolves and returns the ABI function with the specified method name.\r\n * Throws an error if the function is not found in the ABI.\r\n * @template abiFn - The type of the ABI function.\r\n * @param method - The name of the method to resolve.\r\n * @returns The resolved ABI function.\r\n * @throws Error if the function is not found in the ABI.\r\n * @example\r\n * ```ts\r\n * import { resolveMethod, prepareContractCall } from \"thirdweb\";\r\n * const tx = prepareContractCall({\r\n *  contract,\r\n *  // automatically resolves the necessary abi to encode the transaction\r\n *  method: resolveMethod(\"transfer\"),\r\n *  // however there is no type completion for params in this case (as the resolution is async and happens at runtime)\r\n *  params: [to, value],\r\n * });\r\n * ```\r\n * @contract\r\n */\r\nexport function resolveMethod<\r\n  abiFn extends AbiFunction,\r\n  TAbi extends Abi = Abi,\r\n>(method: string) {\r\n  return async (contract: ThirdwebContract<TAbi>) => {\r\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\r\n      // we know it will be an abi function so we can cast it\r\n      return parseAbiItem(method) as AbiFunction;\r\n    }\r\n\r\n    const resolvedAbi = contract.abi?.length\r\n      ? contract.abi\r\n      : await resolveContractAbi<Abi>(contract);\r\n    // we try to find the abiFunction in the abi\r\n    const abiFunction = resolvedAbi.find((item) => {\r\n      // if the item is not a function we can ignore it\r\n      if (item.type !== \"function\") {\r\n        return false;\r\n      }\r\n      // if the item is a function we can compare the name\r\n      return item.name === method;\r\n    }) as abiFn | undefined;\r\n\r\n    if (!abiFunction) {\r\n      throw new Error(`could not find function with name \"${method}\" in abi`);\r\n    }\r\n    return abiFunction;\r\n  };\r\n}\r\n", "import { secp256k1 } from \"@noble/curves/secp256k1\";\r\nimport type { Signature } from \"viem\";\r\n\r\nimport { type Hex, toHex } from \"../encoding/hex.js\";\r\n\r\n/**\r\n * Options for signing a transaction hash.\r\n */\r\nexport type SignOptions = {\r\n  hash: Hex;\r\n  privateKey: Hex;\r\n};\r\n\r\n/**\r\n * Generates the signature for the provided transaction hash.\r\n * @param options - The options for signing.\r\n * @param options.hash - The hash to be signed.\r\n * @param options.privateKey - The private key to sign the hash with.\r\n * @returns The transaction signature.\r\n * @example\r\n * ```ts\r\n * import { sign } from \"thirdweb/utils\";\r\n *\r\n * const signature = sign({\r\n *   hash: \"0x\",\r\n *   privateKey: \"0x\",\r\n * });\r\n * ```\r\n * @utils\r\n */\r\nexport function sign({ hash, privateKey }: SignOptions): Signature {\r\n  const { r, s, recovery } = secp256k1.sign(hash.slice(2), privateKey.slice(2));\r\n  return {\r\n    r: toHex(r, { size: 32 }),\r\n    s: toHex(s, { size: 32 }),\r\n    v: recovery ? 28n : 27n,\r\n    yParity: recovery,\r\n  };\r\n}\r\n", "import {\r\n  type GetTransactionType,\r\n  type SerializedTransactionReturnType,\r\n  type Signature,\r\n  type TransactionSerializable,\r\n  type TransactionType,\r\n  serializeTransaction as _serializeTransaction,\r\n} from \"viem\";\r\n\r\nexport type SerializeTransactionOptions = {\r\n  transaction: TransactionSerializable;\r\n  signature?: Signature | undefined;\r\n};\r\n\r\n/**\r\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\r\n *\r\n * @param options - The serialization options.\r\n * @param options.transaction - The transaction object to be serialized.\r\n * @param [options.signature] - The signature to include with the transaction, if necessary.\r\n * @returns The serialized transaction.\r\n * @throws An error if the provided transaction object is invalid.\r\n * @transaction\r\n * @example\r\n * ```ts\r\n * import { serializeTransaction } from \"thirdweb\";\r\n *\r\n * const serializedTransaction = serializeTransaction({ transaction: {\r\n *    to: \"0x\",\r\n *    value: 0n,\r\n *  }\r\n * });\r\n * ```\r\n */\r\nexport function serializeTransaction<\r\n  const transaction extends TransactionSerializable,\r\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\r\n>(\r\n  options: SerializeTransactionOptions,\r\n): SerializedTransactionReturnType<transaction, _transactionType> {\r\n  const { transaction } = options;\r\n\r\n  // This is to maintain compatibility with our old interface (including the signature in the transaction object)\r\n  const signature = (() => {\r\n    if (options.signature) return options.signature;\r\n    if (transaction.v === undefined && transaction.yParity === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    if (transaction.r === undefined || transaction.s === undefined) {\r\n      throw new Error(\"Invalid signature provided with transaction\");\r\n    }\r\n\r\n    return {\r\n      v: transaction.v,\r\n      r: transaction.r,\r\n      s: transaction.s,\r\n      yParity: transaction.yParity,\r\n    };\r\n  })();\r\n\r\n  return _serializeTransaction(transaction, signature as Signature | undefined); // Trust the options type-checking did its job and that the converted signature mirrors that type\r\n}\r\n", "import type { TransactionSerializable } from \"viem\";\r\nimport type { Hex } from \"../../utils/encoding/hex.js\";\r\nimport { keccak256 } from \"../../utils/hashing/keccak256.js\";\r\nimport { sign } from \"../../utils/signatures/sign.js\";\r\nimport { serializeTransaction } from \"../serialize-transaction.js\";\r\n\r\nexport type SignTransactionOptions = {\r\n  transaction: TransactionSerializable;\r\n  privateKey: Hex;\r\n  // TODO: Add optional custom serializer here\r\n};\r\n\r\n/**\r\n * Signs a transaction to be sent to a node.\r\n * @param options The options for signing.\r\n * @param options.transaction - The transaction object to sign\r\n * @param options.privateKey - The account private key\r\n * @returns The signed transaction as a hex string\r\n * @example\r\n * ```ts\r\n * import { signTransaction } from \"thirdweb\";\r\n * signTransaction({\r\n *   transaction: {\r\n *     ...\r\n *   },\r\n *   privateKey: \"0x...\",\r\n * });\r\n * ```\r\n * @transaction\r\n */\r\nexport function signTransaction({\r\n  transaction,\r\n  privateKey,\r\n}: SignTransactionOptions): Hex {\r\n  if (transaction.type === \"eip4844\") {\r\n    transaction = { ...transaction, sidecars: false };\r\n  }\r\n\r\n  const serializedTransaction = serializeTransaction({ transaction });\r\n\r\n  const signature = sign({\r\n    hash: keccak256(serializedTransaction),\r\n    privateKey: privateKey,\r\n  });\r\n  return serializeTransaction({\r\n    transaction: { ...transaction, ...signature },\r\n  });\r\n}\r\n", "import type { Hex } from \"./is-hex.js\";\r\n\r\ntype TrimOptions = {\r\n  dir?: \"left\" | \"right\";\r\n};\r\ntype TrimReturnType<TValue extends Uint8Array | Hex> = TValue extends Hex\r\n  ? Hex\r\n  : Uint8Array;\r\n\r\n/**\r\n * Trims leading or trailing zeros from a hexadecimal string or byte array.\r\n *\r\n * @param hexOrBytes - The hexadecimal string or byte array to trim.\r\n * @param options - The options for trimming. Default is to trim leading zeros.\r\n * @returns The trimmed hexadecimal string or byte array.\r\n * @internal\r\n */\r\nexport function trim<TValue extends Uint8Array | Hex>(\r\n  hexOrBytes: TValue,\r\n  { dir = \"left\" }: TrimOptions = {},\r\n): TrimReturnType<TValue> {\r\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\r\n  let data: any =\r\n    typeof hexOrBytes === \"string\" ? hexOrBytes.replace(\"0x\", \"\") : hexOrBytes;\r\n\r\n  let sliceLength = 0;\r\n  for (let i = 0; i < data.length - 1; i++) {\r\n    if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") {\r\n      sliceLength++;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  data =\r\n    dir === \"left\"\r\n      ? data.slice(sliceLength)\r\n      : data.slice(0, data.length - sliceLength);\r\n\r\n  if (typeof hexOrBytes === \"string\") {\r\n    if (data.length === 1 && dir === \"right\") {\r\n      data = `${data}0`;\r\n    }\r\n    return `0x${\r\n      data.length % 2 === 1 ? `0${data}` : data\r\n    }` as TrimReturnType<TValue>;\r\n  }\r\n  return data as TrimReturnType<TValue>;\r\n}\r\n", "import { assertSize } from \"./helpers/assert-size.js\";\r\nimport type { Hex } from \"./helpers/is-hex.js\";\r\nimport { trim } from \"./helpers/trim.js\";\r\nimport { hexToBigInt, hexToNumber, uint8ArrayToHex } from \"./hex.js\";\r\n\r\nexport type FromBytesParameters<\r\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\r\n> =\r\n  | TTo\r\n  | {\r\n      /** Size of the bytes. */\r\n      size?: number;\r\n      /** Type to convert to. */\r\n      to: TTo;\r\n    };\r\n\r\nexport type FromBytesReturnType<TTo> = TTo extends \"string\"\r\n  ? string\r\n  : TTo extends \"hex\"\r\n    ? Hex\r\n    : TTo extends \"bigint\"\r\n      ? bigint\r\n      : TTo extends \"number\"\r\n        ? number\r\n        : TTo extends \"boolean\"\r\n          ? boolean\r\n          : never;\r\n\r\n/**\r\n * Converts a Uint8Array to the specified type.\r\n * @param bytes - The Uint8Array to convert.\r\n * @param toOrOpts - The target type or conversion options.\r\n * @returns The converted value of the specified type.\r\n * @example\r\n * ```ts\r\n * import { fromBytes } from \"thirdweb/utils\";\r\n * const bytes = new Uint8Array([1, 164]);\r\n * const number = fromBytes(bytes, \"number\");\r\n * console.log(number); // 420\r\n * ```\r\n * @utils\r\n */\r\nexport function fromBytes<\r\n  TTo extends \"string\" | \"hex\" | \"bigint\" | \"number\" | \"boolean\",\r\n>(\r\n  bytes: Uint8Array,\r\n  toOrOpts: FromBytesParameters<TTo>,\r\n): FromBytesReturnType<TTo> {\r\n  const opts = typeof toOrOpts === \"string\" ? { to: toOrOpts } : toOrOpts;\r\n  switch (opts.to) {\r\n    case \"number\":\r\n      return bytesToNumber(bytes, opts) as FromBytesReturnType<TTo>;\r\n    case \"bigint\":\r\n      return bytesToBigInt(bytes, opts) as FromBytesReturnType<TTo>;\r\n    case \"boolean\":\r\n      return bytesToBool(bytes, opts) as FromBytesReturnType<TTo>;\r\n    case \"string\":\r\n      return bytesToString(bytes, opts) as FromBytesReturnType<TTo>;\r\n    default:\r\n      return uint8ArrayToHex(bytes, opts) as FromBytesReturnType<TTo>;\r\n  }\r\n}\r\n\r\nexport type BytesToBigIntOpts = {\r\n  /** Whether or not the number of a signed representation. */\r\n  signed?: boolean;\r\n  /** Size of the bytes. */\r\n  size?: number;\r\n};\r\n\r\n/**\r\n * Converts a Uint8Array of bytes to a bigint.\r\n * @param bytes - The Uint8Array of bytes to convert.\r\n * @param opts - Optional parameters for the conversion.\r\n * @returns The converted bigint.\r\n * @example\r\n * ```ts\r\n * import { bytesToBigInt } from \"thirdweb/utils\";\r\n * const bytes = new Uint8Array([1, 164]);\r\n * const bigInt = bytesToBigInt(bytes);\r\n * console.log(bigInt); // 420n\r\n * ```\r\n * @utils\r\n */\r\nexport function bytesToBigInt(\r\n  bytes: Uint8Array,\r\n  opts: BytesToBigIntOpts = {},\r\n): bigint {\r\n  if (typeof opts.size !== \"undefined\") {\r\n    assertSize(bytes, { size: opts.size });\r\n  }\r\n  const hex = uint8ArrayToHex(bytes, opts);\r\n  return hexToBigInt(hex, opts);\r\n}\r\n\r\nexport type BytesToBoolOpts = {\r\n  /** Size of the bytes. */\r\n  size?: number;\r\n};\r\n\r\n/**\r\n * Converts a byte array to a boolean value.\r\n * @param bytes_ - The byte array to convert.\r\n * @param opts - Optional parameters for the conversion.\r\n * @returns The boolean value converted from the byte array.\r\n * @throws Error if the byte array is invalid or the boolean representation is invalid.\r\n * @example\r\n * ```ts\r\n * import { bytesToBool } from \"thirdweb/utils\";\r\n * const bytes = new Uint8Array([1]);\r\n * const bool = bytesToBool(bytes);\r\n * console.log(bool); // true\r\n * ```\r\n * @utils\r\n */\r\nexport function bytesToBool(\r\n  bytes_: Uint8Array,\r\n  opts: BytesToBoolOpts = {},\r\n): boolean {\r\n  let bytes = bytes_;\r\n  if (typeof opts.size !== \"undefined\") {\r\n    assertSize(bytes, { size: opts.size });\r\n    bytes = trim(bytes);\r\n  }\r\n\r\n  if (bytes.length > 1 || (bytes[0] && bytes[0] > 1)) {\r\n    throw new Error(`Invalid boolean representation: ${bytes}`);\r\n  }\r\n  return Boolean(bytes[0]);\r\n}\r\n\r\nexport type BytesToNumberOpts = BytesToBigIntOpts;\r\n\r\n/**\r\n * Converts a Uint8Array of bytes to a number.\r\n * @param bytes - The Uint8Array of bytes to convert.\r\n * @param opts - Optional configuration options.\r\n * @returns The converted number.\r\n * @example\r\n * ```ts\r\n * import { bytesToNumber } from \"thirdweb/utils\";\r\n * const bytes = new Uint8Array([1, 164]);\r\n * const number = bytesToNumber(bytes);\r\n * console.log(number); // 420\r\n * ```\r\n * @utils\r\n */\r\nexport function bytesToNumber(\r\n  bytes: Uint8Array,\r\n  opts: BytesToNumberOpts = {},\r\n): number {\r\n  if (typeof opts.size !== \"undefined\") {\r\n    assertSize(bytes, { size: opts.size });\r\n  }\r\n  const hex = uint8ArrayToHex(bytes, opts);\r\n  return hexToNumber(hex, opts);\r\n}\r\n\r\nexport type BytesToStringOpts = {\r\n  /** Size of the bytes. */\r\n  size?: number;\r\n};\r\n\r\n/**\r\n * Converts an array of bytes to a string using UTF-8 encoding.\r\n * @param bytes_ - The array of bytes to convert.\r\n * @param opts - Optional parameters for the conversion.\r\n * @returns The resulting string.\r\n * @example\r\n * ```ts\r\n * import { bytesToString } from \"thirdweb/utils\";\r\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]);\r\n * const string = bytesToString(bytes);\r\n * console.log(string); // \"Hello\"\r\n * ```\r\n * @utils\r\n */\r\nexport function bytesToString(\r\n  bytes_: Uint8Array,\r\n  opts: BytesToStringOpts = {},\r\n): string {\r\n  let bytes = bytes_;\r\n  if (typeof opts.size !== \"undefined\") {\r\n    assertSize(bytes, { size: opts.size });\r\n    bytes = trim(bytes, { dir: \"right\" });\r\n  }\r\n  return new TextDecoder().decode(bytes);\r\n}\r\n", "export const ERC_6492_MAGIC_VALUE =\r\n  \"0x6492649264926492649264926492649264926492649264926492649264926492\" as const;\r\n", "import { sliceHex } from \"viem\";\r\nimport type { Hex } from \"../utils/encoding/hex.js\";\r\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\r\n\r\n/**\r\n * @description Determines if a signature is compatible with [ERC6492](https://eips.ethereum.org/EIPS/eip-6492)\r\n *\r\n * @param {Hex} signature The signature to check for ERC6492 compatibility\r\n *\r\n * @returns {boolean} True if the signature is compatible with ERC6492, false otherwise\r\n *\r\n * @example\r\n * ```ts\r\n * import { isErc6492Signature } from 'thirdweb/auth';\r\n *\r\n * const isErc6492 = isErc6492Signature('0x1234567890123456789012345678901234567890');\r\n * ```\r\n *\r\n * @auth\r\n */\r\nexport function isErc6492Signature(signature: Hex): boolean {\r\n  return sliceHex(signature, -32) === ERC_6492_MAGIC_VALUE;\r\n}\r\n", "import { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\r\nimport { concatHex } from \"../utils/encoding/helpers/concat-hex.js\";\r\nimport type { Hex } from \"../utils/encoding/hex.js\";\r\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\r\nimport type { Erc6492Signature } from \"./types.js\";\r\n\r\n/**\r\n * @description Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.\r\n *\r\n * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format\r\n * @param {string} signature.address The ERC-4337 Account Factory address\r\n * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification\r\n * @param {Hex} signature.signature The original signature\r\n *\r\n * @returns {Hex} The serialized signature\r\n *\r\n * @example\r\n * ```ts\r\n * import { serializeErc6492Signature } from 'thirdweb/auth';\r\n *\r\n * const serializedSignature = serializeErc6492Signature({\r\n *  address: '0x...',\r\n *  data: '0x...',\r\n *  signature: '0x...',\r\n * });\r\n * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492\r\n * ```\r\n * @auth\r\n */\r\nexport function serializeErc6492Signature({\r\n  address,\r\n  data,\r\n  signature,\r\n}: Erc6492Signature): Hex {\r\n  return concatHex([\r\n    encodeAbiParameters(\r\n      [{ type: \"address\" }, { type: \"bytes\" }, { type: \"bytes\" }],\r\n      [address, data, signature],\r\n    ),\r\n    ERC_6492_MAGIC_VALUE,\r\n  ]);\r\n}\r\n", "import { equalBytes } from \"@noble/curves/abstract/utils\";\r\nimport {\r\n  type Signature,\r\n  encodeDeployData,\r\n  serializeSignature,\r\n  universalSignatureValidatorAbi,\r\n  universalSignatureValidatorByteCode,\r\n} from \"viem\";\r\nimport type { Chain } from \"../chains/types.js\";\r\nimport type { ThirdwebClient } from \"../client/client.js\";\r\nimport { type ThirdwebContract, getContract } from \"../contract/contract.js\";\r\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\r\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\r\nimport { getRpcClient } from \"../rpc/rpc.js\";\r\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\r\nimport { type Hex, isHex } from \"../utils/encoding/hex.js\";\r\nimport { toBytes } from \"../utils/encoding/to-bytes.js\";\r\nimport { isErc6492Signature } from \"./is-erc6492-signature.js\";\r\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\r\n\r\nexport type VerifyHashParams = {\r\n  hash: Hex;\r\n  signature: string | Uint8Array | Signature;\r\n  address: string;\r\n  client: ThirdwebClient;\r\n  chain: Chain;\r\n  accountFactory?: {\r\n    address: string;\r\n    verificationCalldata: Hex;\r\n  };\r\n};\r\n\r\n/**\r\n * @description Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\r\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\r\n *\r\n * @param {Hex} options.hash The hash that was signed\r\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\r\n * @param {string} options.address The address that signed the hash\r\n * @param {ThirdwebClient} options.client The Thirdweb client\r\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\r\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\r\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\r\n *\r\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\r\n *\r\n * @example\r\n * ```ts\r\n * import { verifyHash } from \"thirdweb/utils\";\r\n * const isValid = await verifyHash({\r\n *   hash: \"0x1234\",\r\n *   signature: \"0x1234\",\r\n *   address: \"0x1234\",\r\n *   client,\r\n *   chain,\r\n * });\r\n * ```\r\n *\r\n * @auth\r\n */\r\nexport async function verifyHash({\r\n  hash,\r\n  signature,\r\n  address,\r\n  client,\r\n  chain,\r\n  accountFactory,\r\n}: VerifyHashParams): Promise<boolean> {\r\n  const signatureHex = (() => {\r\n    if (isHex(signature)) return signature;\r\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\r\n      return serializeSignature(signature);\r\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\r\n    // We should never hit this but TS doesn't know that\r\n    throw new Error(\r\n      `Invalid signature type for signature ${signature}: ${typeof signature}`,\r\n    );\r\n  })();\r\n\r\n  const wrappedSignature = await (async () => {\r\n    // If no factory is provided, we have to assume its already deployed or is an EOA\r\n    // TODO: Figure out how to automatically tell if our default factory was used\r\n    if (!accountFactory) return signatureHex;\r\n\r\n    // If this sigature was already wrapped for ERC-6492, carry on\r\n    if (isErc6492Signature(signatureHex)) return signatureHex;\r\n\r\n    // Otherwise, serialize the signature for ERC-6492 validation\r\n    return serializeErc6492Signature({\r\n      address: accountFactory.address,\r\n      data: accountFactory.verificationCalldata,\r\n      signature: signatureHex,\r\n    });\r\n  })();\r\n\r\n  const verificationData = encodeDeployData({\r\n    abi: universalSignatureValidatorAbi,\r\n    args: [address, hash, wrappedSignature],\r\n    bytecode: universalSignatureValidatorByteCode,\r\n  });\r\n\r\n  const rpcRequest = getRpcClient({\r\n    chain,\r\n    client,\r\n  });\r\n\r\n  try {\r\n    const result = await eth_call(rpcRequest, {\r\n      data: verificationData,\r\n    });\r\n\r\n    const hexResult = isHex(result) ? toBytes(result) : result;\r\n    return equalBytes(hexResult, toBytes(\"0x1\"));\r\n  } catch {\r\n    // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\r\n    const validEip1271 = await verifyEip1271Signature({\r\n      hash,\r\n      signature: signatureHex,\r\n      contract: getContract({\r\n        chain,\r\n        address,\r\n        client,\r\n      }),\r\n    }).catch(() => false);\r\n    if (validEip1271) {\r\n      return true;\r\n    }\r\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\r\n    // Verification failed somehow\r\n    return false;\r\n  }\r\n}\r\n\r\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\r\nasync function verifyEip1271Signature({\r\n  hash,\r\n  signature,\r\n  contract,\r\n}: {\r\n  hash: Hex;\r\n  signature: Hex;\r\n  contract: ThirdwebContract;\r\n}): Promise<boolean> {\r\n  const result = await isValidSignature({\r\n    hash,\r\n    signature,\r\n    contract,\r\n  });\r\n  return result === EIP_1271_MAGIC_VALUE;\r\n}\r\n", "import type { Signature, TypedData, TypedDataDefinition } from \"viem\";\r\nimport { hashTypedData } from \"viem\";\r\nimport type { Chain } from \"../chains/types.js\";\r\nimport type { ThirdwebClient } from \"../client/client.js\";\r\nimport type { Hex } from \"../utils/encoding/hex.js\";\r\nimport type { HashTypedDataParams } from \"../utils/hashing/hashTypedData.js\";\r\nimport { type VerifyHashParams, verifyHash } from \"./verify-hash.js\";\r\n\r\nexport type VerifyTypedDataParams<\r\n  typedData extends TypedData | Record<string, unknown> = TypedData,\r\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\r\n> = Omit<VerifyHashParams, \"hash\"> &\r\n  TypedDataDefinition<typedData, primaryType> & {\r\n    address: string;\r\n    signature: string | Uint8Array | Signature;\r\n    client: ThirdwebClient;\r\n    chain: Chain;\r\n    accountFactory?: {\r\n      address: string;\r\n      verificationCalldata: Hex;\r\n    };\r\n  };\r\n\r\n/**\r\n * @description Verify am [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data signature. This function is interoperable with all wallet types (smart accounts or EOAs).\r\n *\r\n * @param {string} options.address The address that signed the typed data\r\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\r\n * @param {ThirdwebClient} options.client The Thirdweb client\r\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\r\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\r\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\r\n * @param {typeof VerifyTypedDataParams.message} options.message The EIP-712 message that was signed.\r\n * @param {typeof VerifyTypedDataParams.domain} options.domain The EIP-712 domain that was signed.\r\n * @param {typeof VerifyTypedDataParams.primaryType} options.primaryType The EIP-712 primary type that was signed.\r\n * @param {typeof VerifyTypedDataParams.types} options.types The EIP-712 types that were signed.\r\n *\r\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\r\n * \r\n * @example\r\n * ```ts\r\n * import { verifyTypedData } from \"thirdweb/utils\";\r\n * const isValid = await verifyTypedData({\r\n *   address: \"0x...\",\r\n *   signature: \"0x...\",\r\n *   client,\r\n *   chain,\r\n *   domain: {\r\n      name: \"Ether Mail\",\r\n      version: \"1\",\r\n      chainId: 1,\r\n      verifyingContract: \"0x0000000000000000000000000000000000000000\",\r\n    },\r\n *   primaryType: \"Mail\",\r\n *   types: {\r\n      Person: [\r\n        { name: \"name\", type: \"string\" },\r\n        { name: \"wallet\", type: \"address\" },\r\n      ],\r\n      Mail: [\r\n        { name: \"from\", type: \"Person\" },\r\n        { name: \"to\", type: \"Person\" },\r\n        { name: \"contents\", type: \"string\" },\r\n      ],\r\n    },\r\n    message: {\r\n      from: {\r\n        name: \"Cow\",\r\n        wallet: \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\r\n      },\r\n      to: {\r\n        name: \"Bob\",\r\n        wallet: \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\r\n      },\r\n      contents: \"Hello, Bob!\",\r\n    },\r\n * });\r\n * ```\r\n *\r\n * @auth\r\n */\r\nexport async function verifyTypedData<\r\n  typedData extends TypedData | Record<string, unknown>,\r\n  primaryType extends keyof typedData | \"EIP712Domain\",\r\n>({\r\n  address,\r\n  signature,\r\n  client,\r\n  chain,\r\n  accountFactory,\r\n  message,\r\n  domain,\r\n  primaryType,\r\n  types,\r\n}: VerifyTypedDataParams<typedData, primaryType>): Promise<boolean> {\r\n  const messageHash = hashTypedData({\r\n    message,\r\n    domain,\r\n    primaryType,\r\n    types,\r\n  } as HashTypedDataParams);\r\n  return verifyHash({\r\n    hash: messageHash,\r\n    signature,\r\n    address,\r\n    chain,\r\n    client,\r\n    accountFactory,\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": ["sha256", "sha256", "serializeTransaction", "serializeTransaction"]
}
